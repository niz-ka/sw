#include <LiquidCrystal.h>
LiquidCrystal lcd(9, 8, 4, 5, 6, 7); 

// ###################################

#define SPEAKER A3
#define JUMP_BUTTON 2
#define CROUCH_BUTTON 3
#define ROW_UP 0
#define ROW_DOWN 1


const int delayTime = 500;
volatile bool interrupt_jump = false;
volatile bool interrupt_crouch = false;

enum ActionType {JUMP, CROUCH};

class Action {
  	public:
  	  ActionType type;
  	  bool isRunning;
  	  int left;
};

// -------------------------

class Mylcd {
  public:
  	const unsigned man = 1;
  	const unsigned manJump = 2;
  	const unsigned obstacle_down = 3;
    const unsigned obstacle_up = 4;
    const unsigned manCrouch = 5;
  	const unsigned empty = 32;
  
    void initialize() {
    	lcd.begin(16, 2);
  		//lcd.backlight(); - tylko realna wersja
  		lcd.clear();
  		lcd.setCursor(0, 0);
      
      	byte man_char[8] = {B01100,B01100,B00000,B01110,B11100,B01100,B11010,B10011};
		byte manJump_char[8] = {B01100,B01100,B00000,B11110,B01101,B11111,B10000,B00000};
        byte manCrouch_char[8] = {B00000,B00000,B00000,B01110,B11100,B01100,B11010,B10011};
		byte obstacle_down_char[8] = {B00101,B10101,B10101,B10101,B10110,B01100,B00100,B00100};
        byte obstacle_up_char[8] = {B00100,B00100,B01100,B10110,B10101,B10101,B10101,B00101};
  		
      	lcd.createChar(man, man_char);
  		lcd.createChar(manJump, manJump_char);
  		lcd.createChar(obstacle_down, obstacle_down_char);
        lcd.createChar(obstacle_up, obstacle_up_char);
        lcd.createChar(manCrouch, manCrouch_char);
  	}
  
  	void draw(const unsigned nr) {
    	lcd.write(nr);
  	}
  
  	void drawAt(const unsigned nr, const unsigned column, const unsigned row) {
    	lcd.setCursor(column, row);
      	lcd.write(nr);
  	}
  	
  	void printAt(const char* text, const unsigned column, const unsigned row) {
    	lcd.setCursor(column, row);
      	lcd.print(text);
  	}
  	
};

Mylcd mylcd;


// -----------------------
class Player {
	public:
  	  Action action;
  	  const unsigned xPos = 1;
  	  const unsigned actionLength = 4;
	  
  	  void initialize() {
        action.isRunning = false;
        action.left = 0;
        action.type = JUMP;
        mylcd.drawAt(mylcd.man, xPos, ROW_DOWN);
  	  }
  	  
  	  void update() {
        if(!action.isRunning) {
          if(interrupt_jump) {
             tone(SPEAKER, 500, 100);
             action.isRunning = true;
             action.type = JUMP;
             action.left = actionLength;
             mylcd.drawAt(mylcd.empty, xPos, ROW_DOWN);
             mylcd.drawAt(mylcd.manJump, xPos, ROW_UP);
          } else if (interrupt_crouch) {
             tone(SPEAKER, 400, 100);
             action.isRunning = true;
             action.type = CROUCH;
             action.left = actionLength;
             mylcd.drawAt(mylcd.manCrouch, xPos, ROW_DOWN);
          }
        } else {
           --action.left;
            if(action.left == 0) {
              action.isRunning = false;
              if(action.type == JUMP) {
              	mylcd.drawAt(mylcd.empty, xPos, ROW_UP);
              	mylcd.drawAt(mylcd.man, xPos, ROW_DOWN);
              } else {
                mylcd.drawAt(mylcd.man, xPos, ROW_DOWN); 
              }
              
          	}
        }
        
        interrupt_crouch = false;
        interrupt_jump = false;
  	  }
 	
};


Player player;

class Obstacle {
  public:
  	int xPos;
  	int yPos;
  	
  	void initialize(int xpos, int ypos) {
      xPos = xpos;
      yPos = ypos;
      if(yPos == ROW_UP) {
      	mylcd.drawAt(mylcd.obstacle_up, xPos, yPos);
      } else {
        mylcd.drawAt(mylcd.obstacle_down, xPos, yPos); 
      }

  	}
  
  	void update() {
      if(xPos >= 0 and xPos <= 15) mylcd.drawAt(mylcd.empty, xPos, yPos);
      --xPos;
      if(xPos >= 0 and xPos <= 15) {
        if(yPos == ROW_UP)
        	mylcd.drawAt(mylcd.obstacle_up, xPos, yPos);
        else
           mylcd.drawAt(mylcd.obstacle_down, xPos, yPos);
      }
  	}
};

Obstacle obstacle[3];

const int places[3][3] = {{16,-10,-10}, {16, 17, -10}, {16, 17, 18}};

// --------------------------

void handleJumpInterrupt() {
  interrupt_jump = true;
}

void handleCrouchInterrupt() {
  interrupt_crouch = true;
}

int SCORES = 0;

void changeObstacles() {
  for(int i = 0; i < 3; ++i) {
    if(obstacle[i].xPos >= 0) {
       return; 
    }
  }
 
  int randomX = random(0,3);
  int randomY = random(0,2);
  
  for(int i = 0; i < 3; ++i) {
    obstacle[i].xPos = places[randomX][i];
    obstacle[i].yPos = randomY;
  }
}

void endGame() {
   lcd.clear();
   lcd.print("Koniec gry!");
   lcd.setCursor(0, ROW_DOWN);
   lcd.print("Wynik:");
   lcd.print(SCORES);
   tone(SPEAKER, 500, 500);
   delay(5000);
   
   Serial.println(SCORES);
  
   int i = 1;
   unsigned long timeLoop = millis();
   while(1) {
     if(millis() - timeLoop > 15000) break;
     if(Serial.available() > 0) {
        String data = Serial.readStringUntil('$'); // Tinkercad problem
        lcd.clear();
        lcd.print(i);
        lcd.print(".Wynik:");
        lcd.print(data);
        ++i;
        delay(5000);
        if(i > 3) break;
        timeLoop = millis();
     }
   }
   lcd.clear();
   lcd.print("Restart gry...");
   delay(5000);
  
   lcd.clear();
   lcd.setCursor(0, 0);
   SCORES = 0;
   
    player.initialize();

  	for(int i = 0; i < 3; ++i) {
    	obstacle[i].initialize(13+i, 1);
  	}
  
   interrupt_crouch = false;
   interrupt_jump = false;
}

void checkCollision() {
  for(int i = 0; i < 3; ++i) {
    if(player.xPos == obstacle[i].xPos) {
        if(!player.action.isRunning) endGame();
        else if(player.action.left == 1) endGame();
        else if(obstacle[i].yPos == ROW_UP && player.action.type == JUMP) endGame();
        else if(obstacle[i].yPos == ROW_DOWN && player.action.type == CROUCH) endGame();
    }
    
  }
}

void setup() {
  Serial.begin(9600);
  randomSeed(analogRead(0));
  
  pinMode(SPEAKER, OUTPUT);
  pinMode(JUMP_BUTTON, INPUT_PULLUP);
  pinMode(CROUCH_BUTTON, INPUT_PULLUP);

  attachInterrupt(digitalPinToInterrupt(JUMP_BUTTON), handleJumpInterrupt, FALLING);
  attachInterrupt(digitalPinToInterrupt(CROUCH_BUTTON), handleCrouchInterrupt, FALLING);
  
  mylcd.initialize();
  player.initialize();

  for(int i = 0; i < 3; ++i) {
    obstacle[i].initialize(13+i, 1);
  }
  
}

void loop() {
  
    delay(delayTime);
    player.update();
    for(int i = 0; i < 3; ++i) {
      obstacle[i].update();
    }
    checkCollision();
    changeObstacles();
    ++SCORES;
  
  
}